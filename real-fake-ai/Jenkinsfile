pipeline {
    agent any

    environment {
        // AWS Credentials from Jenkins Credential Store
        AWS_ACCESS_KEY_ID     = credentials('AWS_ACCESS_KEY_ID')
        AWS_SECRET_ACCESS_KEY = credentials('AWS_SECRET_ACCESS_KEY')
        
        // Docker Info
        DOCKER_IMAGE          = "naveenbanwala/real-fake-api"
        IMAGE_TAG             = "${BUILD_NUMBER}"
        
        // K8s Info
        CONTAINER_NAME        = "image-api"
    }

    stages {
        stage('Checkout Code') {
            steps {
                // Pulls everything including the /terraform and /k8s folders
                checkout scm
            }
        }

        stage('Build & Push Image') {
            steps {
                script {
                    // Using withCredentials for Docker Login
                    withCredentials([usernamePassword(credentialsId: 'dockerhub-credentials', usernameVariable: 'USER', passwordVariable: 'PASS')]) {
                        sh "echo \$PASS | docker login -u \$USER --password-stdin"
                        sh "docker build -t ${DOCKER_IMAGE}:latest real-fake-ai"
                        sh "docker tag ${DOCKER_IMAGE}:latest ${DOCKER_IMAGE}:${IMAGE_TAG}"
                        sh "docker push ${DOCKER_IMAGE}:latest"
                        sh "docker push ${DOCKER_IMAGE}:${IMAGE_TAG}"
                    }
                }
            }
        }

      stage('Terraform Infra Provisioning') {
            steps {
                script {
                    // This 'Terraform' must match the name you gave in Jenkins Tools
                    def tfHome = tool name: 'Terraform' 
                    
                    withEnv(["PATH+TF=${tfHome}"]) {
                        dir('terraform') {
                            sh 'terraform init'
                            sh 'terraform apply -auto-approve'
                        }
                    }
                }
            }
        }

        stage('Kubernetes Deployment') {
            steps {
                script {
                    echo "Deploying to Kubernetes Cluster on AWS..."
                    /* Note: In a real EKS setup, you'd run 'aws eks update-kubeconfig'.
                       For your showcase, we will apply the manifests.
                    */
                    sh "kubectl apply -f k8s/deployment.yaml"
                    sh "kubectl apply -f k8s/service.yaml"
                }
            }
        }

        stage('Health Check') {
            steps {
                script {
                    // We need to get the LoadBalancer URL or Node IP from K8s
                    echo "Waiting for Kubernetes Service to provide an endpoint..."
                    
                    timeout(time: 5, unit: 'MINUTES') { 
                        waitUntil {
                            // This command tries to grab the public IP/DNS of the K8s service
                            def status = sh(
                                script: "curl -s -o /dev/null -w '%{http_code}' http://YOUR_EC2_PUBLIC_IP:8000/docs || true", 
                                returnStdout: true
                            ).trim()
                            
                            if (status == "200") {
                                echo "✅ Cloud Deployment is LIVE!"
                                return true
                            } else {
                                echo "Waiting for AWS/K8s to route traffic... (Status: ${status})"
                                return false
                            }
                        }
                    }
                }
            }
        }
    }

    post {
        success { echo '✅ AWS + K8s Deployment Completed Successfully!' }
        failure { echo '❌ Pipeline Failed. Check AWS or Terraform logs.' }
    }
}


// pipeline {
//     agent any

//     environment {
//         DOCKER_IMAGE = "naveenbanwala/real-fake-api"
//         CONTAINER_NAME = "image-api"
//         IMAGE_TAG = "${BUILD_NUMBER}"
//         NETWORK_NAME = "detector-net" // Define a custom network
//     }

//     stages {
//         stage('Checkout Code') {
//             steps {
//                 checkout([$class: 'GitSCM', branches: [[name: '*/main']], userRemoteConfigs: [[url: 'https://github.com/NaveenBanwala/real-fake-image-detector.git']]])
//             }
//         }

//         stage('Build & Push') {
//             steps {
//                 sh """
//                     docker build -t ${DOCKER_IMAGE}:latest real-fake-ai
//                     docker tag ${DOCKER_IMAGE}:latest ${DOCKER_IMAGE}:${IMAGE_TAG}
//                     # Assuming you are already logged in via your credentials block
//                     docker push ${DOCKER_IMAGE}:latest
//                     docker push ${DOCKER_IMAGE}:${IMAGE_TAG}
//                 """
//             }
//         }

//         stage('Deploy Container') {
//             steps {
//                 sh """
//                     # 1. Create the network if it doesn't exist
//                     docker network create ${NETWORK_NAME} || true
                    
//                     # 2. Stop and remove old container
//                     docker rm -f ${CONTAINER_NAME} || true

//                     # 3. Run the container on the custom network
//                     docker run -d \
//                         --name ${CONTAINER_NAME} \
//                         --network ${NETWORK_NAME} \
//                         -p 8000:8000 \
//                         --restart unless-stopped \
//                         ${DOCKER_IMAGE}:latest
                    
//                     # 4. Connect Jenkins to the same network (Crucial!)
//                     # We use 'hostname -i' or similar to find Jenkins' own container ID
//                     JENKINS_CONTAINER_ID=\$(cat /proc/self/cgroup | grep 'docker' | sed 's/^.*\\///' | tail -n1)
//                     docker network connect ${NETWORK_NAME} \$JENKINS_CONTAINER_ID || true
//                 """
//             }
//         }

//  stage('Health Check') {
//     steps {
//         script {
//             echo "Checking connectivity via container name: http://${CONTAINER_NAME}:8000/docs"
            
//             timeout(time: 2, unit: 'MINUTES') { // AI models can take a moment to load
//                 waitUntil {
//                     // We add '|| true' so curl failing doesn't kill the whole pipeline
//                     def status = sh(
//                         script: "curl -s -o /dev/null -w '%{http_code}' http://${CONTAINER_NAME}:8000/docs || true", 
//                         returnStdout: true
//                     ).trim()
                    
//                     if (status == "200") {
//                         echo "✅ App is up and running!"
//                         return true
//                     } else {
//                         echo "Waiting for app... (Current Status: ${status})"
//                         return false
//                     }
//                 }
//             }
//         }
//     }
// }
// }

//     post {
//         success { echo '✅ CI/CD Pipeline Completed Successfully!' }
//         failure { echo '❌ Pipeline Failed. Check logs.' }
//     }
// }