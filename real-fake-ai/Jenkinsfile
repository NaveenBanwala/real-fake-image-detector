pipeline {
    agent any

    environment {
        // AWS Credentials from Jenkins Credential Store
        AWS_ACCESS_KEY_ID     = credentials('AWS_ACCESS_KEY_ID')
        AWS_SECRET_ACCESS_KEY = credentials('AWS_SECRET_ACCESS_KEY')
        
        // Docker Info
        DOCKER_IMAGE          = "naveenbanwala/real-fake-api"
        IMAGE_TAG             = "${BUILD_NUMBER}"
        
        // K8s Info
        CONTAINER_NAME        = "image-api"
    }

    stages {
        stage('Checkout Code') {
            steps {
                // Pulls everything including the /terraform and /k8s folders
                checkout scm
            }
        }

        stage('Build & Push Image') {
            steps {
                script {
                    // Using withCredentials for Docker Login
                    withCredentials([usernamePassword(credentialsId: 'dockerhub-credentials', usernameVariable: 'USER', passwordVariable: 'PASS')]) {
                        sh "echo \$PASS | docker login -u \$USER --password-stdin"
                        sh "docker build -t ${DOCKER_IMAGE}:latest real-fake-ai"
                        sh "docker tag ${DOCKER_IMAGE}:latest ${DOCKER_IMAGE}:${IMAGE_TAG}"
                        sh "docker push ${DOCKER_IMAGE}:latest"
                        sh "docker push ${DOCKER_IMAGE}:${IMAGE_TAG}"
                    }
                }
            }
        }

  stage('Terraform Infra Provisioning') {
        steps {
            script {
                def tfHome = tool name: 'Terraform' 
                
                withEnv(["PATH+TF=${tfHome}"]) {
                    dir('real-fake-ai/terraform') { 
                        // Force clean the stale state from us-east-1
                        // sh 'rm -rf .terraform* terraform.tfstate*'
                        
                        sh 'terraform init'
                        sh 'terraform apply -auto-approve'
                    }
                }
            }
        }
    }

    stage('Kubernetes Deployment') {
            steps {
                script {
                    def serverIp = "3.111.150.46" // Ensure this is your actual EC2 IP
                    
                    sshagent(['aws-ssh-key']) {
                        sh """
                        ssh -o StrictHostKeyChecking=no ubuntu@${serverIp} << 'EOF'
                            # 1. Wait for K3s to initialize
                            until sudo kubectl get nodes; do sleep 5; done
                            
                            # 2. Deploy the app using K8s (The Resume Move)
                            # We create a deployment and expose it as a NodePort
                            sudo kubectl delete deployment ${CONTAINER_NAME} || true
                            sudo kubectl create deployment ${CONTAINER_NAME} --image=${DOCKER_IMAGE}:latest
                            
                            # 3. Expose port 8000
                            sudo kubectl delete service ${CONTAINER_NAME} || true
                            sudo kubectl expose deployment ${CONTAINER_NAME} --type=NodePort --port=8000 --target-port=8000
                            
                            # 4. Patch the service to use a fixed port (optional but easier for Health Check)
                            # This makes the app available specifically on port 30001
                            # sudo kubectl patch svc ${CONTAINER_NAME} --type='json' -p '[{"op":"replace","path":"/spec/ports/0/nodePort","value":30001}]'
                        EOF
                        """
                    }
                }
            }
        }

        stage('Health Check') {
            steps {
                script {
                    def serverIp = "3.111.150.46"
                    echo "Checking health at http://${serverIp}:8000..."
                    
                    // Retries for 2 minutes while the container starts
                    timeout(time: 2, unit: 'MINUTES') {
                        waitUntil {
                            def status = sh(
                                script: "curl -s -o /dev/null -w '%{http_code}' http://${serverIp}:8000/docs || true",
                                returnStdout: true
                            ).trim()
                            return (status == "200")
                        }
                    }
                    echo "✅ Application is LIVE on Kubernetes!"
                }
            }
        }

//   stage('Kubernetes Deployment') {
//             steps {
//                 script {
//                     sh '''
//                         # 1. Download the kubectl binary
//                         curl -LO "https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl"
                        
//                         # 2. Make it executable
//                         chmod +x ./kubectl
                        
//                         # 3. Use it (using ./ to point to the local file)
//                         ./kubectl version --client
                        
//                         # 4. Apply your manifests (assuming they are in a 'k8s' folder)
//                         # ./kubectl apply -f real-fake-ai/k8s/deployment.yaml
//                         # ./kubectl apply -f real-fake-ai/k8s/service.yaml
//                     '''
//                 }
//             }
//         }

    
//     // stage('Deploy to EC2') {
//     //     steps {
//     //         script {
//     //             // The IP from your last Terraform run
//     //             def serverIp = "3.111.150.46" 
                
//     //             // This requires an SSH credential in Jenkins named 'aws-ssh-key'
//     //             sshagent(['aws-ssh-key']) {
//     //                 sh """
//     //                 ssh -o StrictHostKeyChecking=no ubuntu@${serverIp} << 'EOF'
//     //                     # Install Docker
//     //                     sudo apt-get update
//     //                     sudo apt-get install -y docker.io
                        
//     //                     # Stop existing container if it exists
//     //                     sudo docker stop image-api || true
//     //                     sudo docker rm image-api || true
                        
//     //                     # Pull your new image and run it
//     //                     sudo docker pull ${DOCKER_IMAGE}:latest
//     //                     sudo docker run -d --name image-api -p 8000:8000 ${DOCKER_IMAGE}:latest
//     //                 EOF
//     //                 """
//     //             }
//     //         }
//     //     }
//     // }

//         stage('Health Check') {
//             steps {
//                 script {
//                     // We need to get the LoadBalancer URL or Node IP from K8s
//                     echo "Waiting for Kubernetes Service to provide an endpoint..."
                    
//                     timeout(time: 5, unit: 'MINUTES') { 
//                         waitUntil {
//                             // This command tries to grab the public IP/DNS of the K8s service
//                             def status = sh(
//                                 script: "curl -s -o /dev/null -w '%{http_code}' http://YOUR_EC2_PUBLIC_IP:8000/docs || true", 
//                                 returnStdout: true
//                             ).trim()
                            
//                             if (status == "200") {
//                                 echo "✅ Cloud Deployment is LIVE!"
//                                 return true
//                             } else {
//                                 echo "Waiting for AWS/K8s to route traffic... (Status: ${status})"
//                                 return false
//                             }
//                         }
//                     }
//                 }
//             }
//         }
//     }



    post {
        success { echo '✅ AWS + K8s Deployment Completed Successfully!' }
        failure { echo '❌ Pipeline Failed. Check AWS or Terraform logs.' }
    }
}


// pipeline {
//     agent any

//     environment {
//         DOCKER_IMAGE = "naveenbanwala/real-fake-api"
//         CONTAINER_NAME = "image-api"
//         IMAGE_TAG = "${BUILD_NUMBER}"
//         NETWORK_NAME = "detector-net" // Define a custom network
//     }

//     stages {
//         stage('Checkout Code') {
//             steps {
//                 checkout([$class: 'GitSCM', branches: [[name: '*/main']], userRemoteConfigs: [[url: 'https://github.com/NaveenBanwala/real-fake-image-detector.git']]])
//             }
//         }

//         stage('Build & Push') {
//             steps {
//                 sh """
//                     docker build -t ${DOCKER_IMAGE}:latest real-fake-ai
//                     docker tag ${DOCKER_IMAGE}:latest ${DOCKER_IMAGE}:${IMAGE_TAG}
//                     # Assuming you are already logged in via your credentials block
//                     docker push ${DOCKER_IMAGE}:latest
//                     docker push ${DOCKER_IMAGE}:${IMAGE_TAG}
//                 """
//             }
//         }

//         stage('Deploy Container') {
//             steps {
//                 sh """
//                     # 1. Create the network if it doesn't exist
//                     docker network create ${NETWORK_NAME} || true
                    
//                     # 2. Stop and remove old container
//                     docker rm -f ${CONTAINER_NAME} || true

//                     # 3. Run the container on the custom network
//                     docker run -d \
//                         --name ${CONTAINER_NAME} \
//                         --network ${NETWORK_NAME} \
//                         -p 8000:8000 \
//                         --restart unless-stopped \
//                         ${DOCKER_IMAGE}:latest
                    
//                     # 4. Connect Jenkins to the same network (Crucial!)
//                     # We use 'hostname -i' or similar to find Jenkins' own container ID
//                     JENKINS_CONTAINER_ID=\$(cat /proc/self/cgroup | grep 'docker' | sed 's/^.*\\///' | tail -n1)
//                     docker network connect ${NETWORK_NAME} \$JENKINS_CONTAINER_ID || true
//                 """
//             }
//         }

//  stage('Health Check') {
//     steps {
//         script {
//             echo "Checking connectivity via container name: http://${CONTAINER_NAME}:8000/docs"
            
//             timeout(time: 2, unit: 'MINUTES') { // AI models can take a moment to load
//                 waitUntil {
//                     // We add '|| true' so curl failing doesn't kill the whole pipeline
//                     def status = sh(
//                         script: "curl -s -o /dev/null -w '%{http_code}' http://${CONTAINER_NAME}:8000/docs || true", 
//                         returnStdout: true
//                     ).trim()
                    
//                     if (status == "200") {
//                         echo "✅ App is up and running!"
//                         return true
//                     } else {
//                         echo "Waiting for app... (Current Status: ${status})"
//                         return false
//                     }
//                 }
//             }
//         }
//     }
// }
// }

//     post {
//         success { echo '✅ CI/CD Pipeline Completed Successfully!' }
//         failure { echo '❌ Pipeline Failed. Check logs.' }
//     }
// }